import socket, time
import threading
import hashlib
import pickle

from .utils import contain
NUM_OF_BITS = 6

class P2PNode:
    """
    node of Chord DHT
    node's id is generated by hash function
    """
    
    def __init__(self, logger, addr, host_addr=None):
        self.addr = addr
        self.host_addr = host_addr
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket.bind(addr)
        self.socket.listen(5)
        self.id = self.hash(self.addr)
        self.finger_table = list(("",0) for i in range(NUM_OF_BITS))
        self.init_finger_table()
        self.predecessor_addr = None
        self.predecessor_id = -1
        self.successor_addr = self.addr
        self.successor_id = self.id
        
        #self.data = {}
        self.lock = threading.Lock()
        self.alive = True
        
        self.thread = threading.Thread(target=self.run, daemon=True)
        self.thread.start()
        self.join()
        self.logger = logger
        """
        loop for stablize after few seconds, to update finger table, successor and predecessor after join or unjoin of other nodes
        """
        threading.Thread(target=self.stabilize, daemon=True).start()
        threading.Thread(target=self.fix_fingers, daemon=True).start()

        while self.alive:
            time.sleep(10)
        
        
    def init_finger_table(self):
        """
        initialize finger table
        """
        for i in range(NUM_OF_BITS):
            self.finger_table[i] = (self.addr, self.id)    
    
    def hash(self, addr):
        """
        hash function, that generated id of node by address, using sha1
        """
        return int(hashlib.sha1(str(addr).encode()).hexdigest(), 16) % (2**NUM_OF_BITS)
    
    def run(self):
        """
        thread for listening
        """
        while self.alive:
            conn, addr = self.socket.accept()
            data = conn.recv(1024)
            if data:
                self._handle(data, conn)
            conn.close()
    
    def join(self):
        """
        join to the network
        """
        if self.host_addr:
            self._find_successor(self.host_addr)
            self._notify()
        else:
            self.successor_addr = self.addr
            self.predecessor_addr = self.addr
            self.successor_id = self.id
            self.predecessor_id = self.id
    
    def stabilize(self):
        """
        stabilize the network
        """
        while self.alive:
            while(self.successor_addr != self.addr):
                if self.successor_addr != self.addr:
                    try:
                        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        sock.connect(self.successor_addr)
                        sock.send(pickle.dumps(('get_predecessor', self.addr, self.id)))
                        data = pickle.loads(sock.recv(1024))
                        sock.close()
                        if data[1] != -1 and contain(data[1], self.id, self.successor_id):
                            self.successor_addr = data[0]
                            self.successor_id = data[1]
                        self._notify()
                    except:
                        """
                        connect to next address in finger table
                        """
                        for i,addr in enumerate(self.finger_table):
                            if (addr[0] != self.successor_addr):
                                self.successor_addr = addr[0]
                                self.successor_id = addr[1]
                                for j in range(i):
                                    self.finger_table[j] = self.finger_table[i]
                                break
                        self._notify_leave()
                    time.sleep(5)
            time.sleep(5)
                       
    def fix_fingers(self):
        """
        fix fingers
        """
        while self.alive:
            while self.successor_addr != self.addr:
                self._update_finger_table()
                self.print_finger_table()
                time.sleep(5)
            time.sleep(5)   
    
    def _find_successor(self, addr):
        """
        find successor of id, data sent by pickle
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect(addr)
        sock.send(pickle.dumps(('find_successor', self.addr, self.id)))
        data = pickle.loads(sock.recv(1024))
        """
        get successor address and id with mutex
        """
        self.lock.acquire()
        self.successor_addr = data[0]
        self.successor_id = data[1]
        self.lock.release()
        sock.close()
  
    def _notify(self):
        """
        notify successor about self
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect(self.successor_addr)
        sock.send(pickle.dumps(('notify', self.addr, self.id)))
        sock.close()

    def _update_finger_table(self):
        """
        update finger table
        """
        self.finger_table[0] = (self.successor_addr, self.successor_id)
        for i in range(1, NUM_OF_BITS):
            id = (self.id + 2 ** i) % 2 ** NUM_OF_BITS
            if(self._find_successor_by_id(id, None)!=None):
                self.finger_table[i] = self._find_successor_by_id(id, None)
    
    def _find_successor_by_id(self, id, conn):
        """
        find successor of id
        """
        if contain(id, self.id, self.successor_id):
            if conn:
                conn.send(pickle.dumps((self.successor_addr, self.successor_id)))
            else:
                return (self.successor_addr, self.successor_id)
        else:
            if conn:
                self._find_closest_preceding_finger(id, conn)
            else:
                return self._find_closest_preceding_finger(id, None)
    
    def _find_closest_preceding_finger(self, id:int, conn):
        """
        find closest preceding finger
        """
        
        for i in range(NUM_OF_BITS - 1, -1, -1):
            if contain(self.finger_table[i][1], self.id, id):

                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.connect(self.finger_table[i][0])
                    sock.send(pickle.dumps(('find_successor_by_id', self.addr, self.id, id)))
                    data = pickle.loads(sock.recv(1024))
                    sock.close()
                except:
                    data = self.finger_table[(i+1)%NUM_OF_BITS]
                    
                if conn:
                    conn.send(pickle.dumps(data))
                else:
                    return data
                break
            else:
                continue
    
    ######################## for handle a request ########################
    
    def _handle(self, data, conn):
        """
        handle data from other nodes
        """
        data = pickle.loads(data)
        if data[0] == 'find_successor':
            self._handle_find_successor(data, conn)
        elif data[0] == 'notify':
            self._handle_notify(data)
        elif data[0] == 'notify_leave':
            self._handle_notify_leave(data)
        elif data[0] == 'get_predecessor':
            self._handle_get_predecessor(data, conn)
        elif data[0] == 'find_successor_by_id':
            self._handle_find_successor_by_id(data, conn)
       
    def _handle_find_successor(self, data, conn):
        """
        handle find_successor request
        """
        if self.id == self.successor_id:
            conn.send(pickle.dumps((self.addr, self.id)))
            self.lock.acquire()
            self.successor_addr = data[1]
            self.successor_id = data[2]
            self.finger_table[0] = (self.successor_addr, self.successor_id)
            self.lock.release()
        elif contain(data[2], self.id, self.successor_id):
            conn.send(pickle.dumps((self.successor_addr, self.successor_id)))
            self.lock.acquire()
            self.successor_addr = data[1]
            self.successor_id = data[2]
            self.finger_table[0] = (self.successor_addr, self.successor_id)
            self.lock.release()        
        else:
            self._find_successor_by_id(data[2], conn)
     
    def _handle_notify(self, data):
        """
        handle notify request
        """
        if self.predecessor_id == -1 or contain(data[2], self.predecessor_id, self.id):
            self.lock.acquire()
            self.predecessor_addr = data[1]
            self.predecessor_id = data[2]
            self.lock.release()
 
    def _notify_leave(self):
        """
        notify successor that node's predecessor has left
        """

        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect(self.successor_addr)
        sock.send(pickle.dumps(('notify_leave', self.addr, self.id)))
        sock.close()
    
    def _handle_notify_leave(self, data):
        """
        handle notify_leave request
        """
        self.lock.acquire()
        self.predecessor_addr = data[1]
        self.predecessor_id = data[2]
        self.lock.release()
    
    def _handle_get_predecessor(self, data, conn):
        """
        handle get_predecessor request
        """
        conn.send(pickle.dumps((self.predecessor_addr, self.predecessor_id)))

    def _handle_find_successor_by_id(self, data, conn):
        """
        handle find_successor_by_id request
        """
        self._find_successor_by_id(data[3], conn)

    
    ############################# for logging ############################
    def print_finger_table(self):
        """
        print finger table with ideal id
        """
        message = "\nself id : %d || succ id : %d || pred id : %d" % (self.id, self.successor_id, self.predecessor_id)
        message+="\n<finger table>"
        
        for i,elem in enumerate(self.finger_table):
            id = (self.id + 2 ** i) % 2 ** NUM_OF_BITS
            message+="\n%2d | %s:%d (%2d)" % (id, elem[0][0], elem[0][1], elem[1])
        message+="\n"
        self.logger.info(message)
